#include "chassis.h"

	
//底盘电机通信设备句柄
static rt_device_t 		chassis_communication	= RT_NULL;

//底盘电机PID线程句柄
static rt_thread_t 		contral_speed_thread 	= RT_NULL;

//电机控制结构体，索引0对应最小ID
static motor_t				chassis_motor[4];

//运动数据，包括云台两轴角度，期望速度等
static motion_data_t	motion_data;


#define ABS(a) (((a)>0)?(a):(-a))
/**
* @brief：该函数根据参数初始化pid结构体并进行状态归零
* @param [in]	参数说明详见 motorpid_t 结构体
* @return：		无
* @author：mqy
*/
static void pid_init(motorpid_t* motorpid,float kp,float ki,float kd,
					float i_limit,rt_int16_t out_limit_up,rt_int16_t out_limit_down)
{
	//参数设置
	motorpid->kp = kp;
	motorpid->ki = ki;
	motorpid->kd = kd;
	motorpid->i_limit = i_limit;
	motorpid->out_limit_up = out_limit_up;
	motorpid->out_limit_down = out_limit_down;
	//状态归零
	motorpid->err = 0;
	motorpid->err_old = 0;
	motorpid->i_value = 0;
	motorpid->out = 0;
}
/**
* @brief：该函数根据四个电机的设定参数分别计算出其输出
* @param [in]	target:要计算的pid结构体
							error:期望值与实际值的误差（单位rpm
* @return：		无
* @author：mqy
*/
static void pid_output_calculate(motorpid_t* target,rt_int16_t error)
{
	target->err_old = target->err;
	target->err = error;
	target->i_value += target->ki * error;
	
	//积分限幅
	if(target->i_value < 0)
	{
		if(target->i_value < -target->i_limit)
		{
			target->i_value = -target->i_limit;
		}
	}
	else
	{
		if(target->i_value > target->i_limit)
		{
			target->i_value = target->i_limit;
		}
	}
	target->out = target->kp*(float)error + target->i_value + target->kd*(float)(target->err - target->err_old);
	
	//输出限幅
	if(target->out > target->out_limit_up)
	{
		target->out = target->out_limit_up;
	}
	else if(target->out < target->out_limit_down)
	{
		target->out = target->out_limit_down;
	}
}
/**
* @brief：按照参数设定底盘的运动角速度与速度，速度结果将会被保存在本文件的四个轮子的数据中
* @param [in]	angle:设定本次操作的正方向（即本次操作的水平坐标系的y轴正方向
											该值大小范围0~8191，对应了角度范围0~359.95度，
							angular_velocity:设定底盘自转角速度（单位 0.1 °/s 即 pi/1800 rad/s
							xspeed:期望的x轴速度分量（单位mm/s
							yspeed:期望的y轴速度分量（单位mm/s
* @return：		无
* @author：mqy
*/
static void motor_speed_set(rt_uint16_t angle,rt_int16_t angular_velocity,rt_int16_t xspeed,rt_int16_t yspeed)
{
	while(angle > 8191)
	{
		angle -= 8191;
	}
	angle = 8191 - angle;
	//储存角度变换之后的线速度
	float y = yspeed*cos((double)(angle)/4096*3.1415926) + xspeed*cos((double)(angle - 6144)/4096*3.1415926);
	float x = -yspeed*cos((double)(angle + 2048)/4096*3.1415926) + xspeed*cos((double)(angle)/4096*3.1415926);
	
	float v1 = (float)1.41421*(y + x) + angular_velocity*((float)3.1415926/(float)1800.0*(VEHICLE_WIDTH + VEHICLE_LONG));
	float v2 = (float)1.41421*(y - x) - angular_velocity*((float)3.1415926/(float)1800.0*(VEHICLE_WIDTH + VEHICLE_LONG));
	float v3 = (float)1.41421*(y - x) + angular_velocity*((float)3.1415926/(float)1800.0*(VEHICLE_WIDTH + VEHICLE_LONG));
	float v4 = (float)1.41421*(y + x) - angular_velocity*((float)3.1415926/(float)1800.0*(VEHICLE_WIDTH + VEHICLE_LONG));
	
	//2.40946为单位转换的系数，v为期望的轮子线速度，期望速度使用rpm作为单位
	chassis_motor[(rt_uint8_t)(LEFT_FRONT	- MIN_ID)].expected_speed = (rt_int16_t)((float)2.40946*v1);
	chassis_motor[(rt_uint8_t)(RIGHT_FRONT- MIN_ID)].expected_speed = -(rt_int16_t)((float)2.40946*v2);
	chassis_motor[(rt_uint8_t)(LEFT_BACK	- MIN_ID)].expected_speed = (rt_int16_t)((float)2.40946*v3);
	chassis_motor[(rt_uint8_t)(RIGHT_BACK	- MIN_ID)].expected_speed = -(rt_int16_t)((float)2.40946*v4);
}
/**
* @brief：该函数根据设定运动模式和设定线速度角速度调用函数motor_speed_set设定电机速度
					在初始化之后该函数每经过x ms会执行一次
* @param [in]	无
* @return：		无
* @author：mqy
*/
static void chassis_contral(void)
{
	switch(motion_data.sport_mode)
	{
		case NO_FOLLOW:
		{
			motor_speed_set(
			motion_data.yaw_data.angle,			//传入当前角度参数
			motion_data.angular_velocity,		//不跟随时传入当前角速度
			motion_data.xspeed,
			motion_data.yspeed
			);
			//chassis_speed_set();
			break;
		}
		case FOLLOW:
		{
			//在跟随模式下需要计算设定角速度
			rt_int16_t error = motion_data.follow_angle - motion_data.yaw_data.angle;
			if(ABS(error) > (8191 - ABS(error)))
			{
				if(error > 0)
				{
					error = 8191 - error;
				}
				else
				{
					error = 8191 + error;
				}
			}
			pid_output_calculate(&motion_data.anglepid,error);
			
			motor_speed_set(
			motion_data.yaw_data.angle,//传入当前角度参数
			motion_data.anglepid.out,//跟随时传入角度环闭环的参数
			motion_data.xspeed,
			motion_data.yspeed
			);
			break;
		}
		default:
			
			break;
	}
}
/**
* @brief：根据四个电机的设定参数分别计算出其输出并发送数据
					在初始化之后该函数每经过x ms会执行一次
* @param [in]	parameter:该参数不会被使用
* @return：		无
* @author：mqy
*/
//2ms任务
static struct rt_timer task_2ms;
static struct rt_semaphore chassis_2ms_sem;
static void task_2ms_IRQHandler(void *parameter)
{
	rt_sem_release(&chassis_2ms_sem);
}
static void chassis_speed_contral(void* parameter)
{
	struct rt_can_msg wheelc_message;
	
	wheelc_message.id	= MOTOR_MESSAGE_ID;	//设置ID
	wheelc_message.ide	= RT_CAN_STDID;		//标准帧
	wheelc_message.rtr	= RT_CAN_DTR;		//数据帧
	wheelc_message.priv = 0;				//报文优先级最高
	wheelc_message.len = 8;					//长度8
	rt_int16_t motor_error;					//临时存储电机偏差
	rt_uint16_t send_failure = 0;			//用于记录发送失败次数
	
	while(1)
	{
		rt_sem_take(&chassis_2ms_sem, RT_WAITING_FOREVER);
		chassis_contral();
		for(int a = 0;a<4;a++)
		{
			motor_error = chassis_motor[a].expected_speed - chassis_motor[a].motordata.speed;
			pid_output_calculate(&chassis_motor[a].motorpid,motor_error);
			//chassis_motor[a].motorpid.out = 200;
		}
		
		//发送数据
		wheelc_message.data[0] = chassis_motor[0].motorpid.out>>8;
		wheelc_message.data[1] = chassis_motor[0].motorpid.out;
		wheelc_message.data[2] = chassis_motor[1].motorpid.out>>8;
		wheelc_message.data[3] = chassis_motor[1].motorpid.out;
		wheelc_message.data[4] = chassis_motor[2].motorpid.out>>8;
		wheelc_message.data[5] = chassis_motor[2].motorpid.out;
		wheelc_message.data[6] = chassis_motor[3].motorpid.out>>8;
		wheelc_message.data[7] = chassis_motor[3].motorpid.out;
		
		if(!rt_device_write(chassis_communication,0,&wheelc_message,sizeof(wheelc_message)))
		{
			//如果发送数据为0计数一次发送失败，失败次数过多发出警告
			send_failure++;
			if(send_failure > 500)//持续失败一定时间后发送警告
			{
				rt_kprintf("cant send chassis message,please find mqy\n");
			}
		}
		else
		{
			send_failure = 0;
		}
	}
}

/**
* @brief：初始化底盘电机
* @param [in]	无
* @return：		true:初始化成功
							false:初始化失败
* @author：mqy
*/
bool chassis_init(void)
{
	chassis_communication = rt_device_find("can1");
	//当查找不到设备句柄时初始化失败
	if(!chassis_communication)
	{
		return false;
	}
	
	if(RT_EOK != rt_device_control(chassis_communication, RT_CAN_CMD_SET_BAUD, (void *)CAN1MBaud))
	{
		return false;
	}
	
	if(RT_EOK != rt_device_control(chassis_communication, RT_CAN_CMD_SET_MODE, (void *)RT_CAN_MODE_NORMAL))
	{
		return false;
	}
//	//尝试打开设备，创建一个储存状态的临时变量i，该变量只被使用了一次
//	rt_err_t i = rt_device_open(chassis_communication,RT_DEVICE_FLAG_INT_TX 
//																									| RT_DEVICE_FLAG_INT_RX );
//	//当打开失败时返回false
//	if(!((i == RT_EOK)||(i == -RT_EBUSY)))
//	{
//		return false;
//	}
	
	rt_sem_init(&chassis_2ms_sem, "2ms_sem", 0, RT_IPC_FLAG_FIFO);
	//若没有创建过线程则创建PID控制线程
	if(contral_speed_thread == RT_NULL)
	{
		contral_speed_thread = rt_thread_create(
		"contral_speed_thread",		//线程名
		chassis_speed_contral,		//线程入口
		RT_NULL,									//入口参数无
		2048,											//线程栈
		CHASSIS_CONTRAL_PRIORITY,	//线程优先级
		2);												//线程时间片大小
	}
	
	//线程创建失败返回false
	if(contral_speed_thread == RT_NULL)
	{
		return false;
	}
	
	//线程启动失败返回false
	if(rt_thread_startup(contral_speed_thread) != RT_EOK)
	{
		return false;
	}
	
	//创建线程定时器
	rt_timer_init(&task_2ms,
                 "2ms_task",
                 task_2ms_IRQHandler,
								 RT_NULL,
                 2, RT_TIMER_FLAG_PERIODIC | RT_TIMER_FLAG_SOFT_TIMER);
	
	//启动定时器
	rt_timer_start(&task_2ms);
	
	//若均成功则开始初始化数据
	for(uint16_t a = 0;a<4;a++)
	{
		chassis_motor[a].expected_speed = 0;
		chassis_motor[a].motorID = (motorID_e)(MIN_ID + a);//初始化ID数值
	}
	pid_init(&chassis_motor[0].motorpid,7,0.005,5,500,8000,-8000);
	pid_init(&chassis_motor[1].motorpid,7,0.005,5,500,8000,-8000);
	pid_init(&chassis_motor[2].motorpid,7,0.005,5,500,8000,-8000);
	pid_init(&chassis_motor[3].motorpid,7,0.005,5,500,8000,-8000);
	pid_init(&motion_data.anglepid,2,0,10,10,1000,-1000);
	motion_data.follow_angle = 0;
	motion_data.angular_velocity = 0;
	motion_data.xspeed = 0;
	motion_data.yspeed = 0;
	motion_data.sport_mode = NO_FOLLOW;//默认不跟随
	return true;
}
/**
* @brief：按照参数设定以云台为前方的速度
* @param [in]	follow_angle:设定跟随角度（单位° 范围0-360，超出范围的会转化到该范围内
							angular_velocity:设定底盘自转角速度（单位 0.1 °/s 即 pi/1800 rad/s
							xspeed:期望的x轴速度分量（单位mm/s
							yspeed:期望的y轴速度分量（单位mm/s
* @return：		无
* @author：mqy
*/
void chassis_speed_set(rt_uint16_t follow_angle,rt_int16_t angular_velocity,rt_int16_t xspeed,rt_int16_t yspeed)
{
	while(follow_angle > 8191)
	{
		follow_angle -= 8191;
	}
	motion_data.follow_angle = follow_angle;
	motion_data.angular_velocity = angular_velocity;
	motion_data.xspeed = xspeed;
	motion_data.yspeed = yspeed;
}
/**
* @brief：refresh_motor_data函数会使用该函数来更新数据
* @param [in]	message:接收到的数据帧指针
							motordata:要更新的电机数据结构体指针
* @return：		无
* @author：mqy
*/
static void assign_motor_data(motordata_t* motordata,struct rt_can_msg* message)
{
	motordata->angle = (message->data[0]<<8) + message->data[1];	//转子角度
	motordata->speed = (message->data[2]<<8) + message->data[3];	//转子转速
	motordata->current = (message->data[4]<<8) + message->data[5];//实际电流
	motordata->temperature = message->data[6];										//温度
}
/**
* @brief：利用该函数更新底盘电机当前转速等数据
* @param [in]	message:接收到的数据帧指针
* @return：		true:更新成功
							false:id不匹配更新失败
* @author：mqy
*/
bool refresh_chassis_motor_data(struct rt_can_msg* message)
{
	rt_uint8_t coordinate = message->id - MIN_ID;
	
	//底盘四个电机数据
	if(coordinate < 4)
	{
		assign_motor_data(&chassis_motor[coordinate].motordata,message);
		return true;//更新完数据就返回
	}
	return false;
}
bool refresh_yuntai_motor_data(struct rt_can_msg* message)
{
	//其他数据
	switch(message->id)
	{
		case YAW:
			assign_motor_data(&motion_data.yaw_data,message);
			//转换角度数值的坐标系
			if(motion_data.yaw_data.angle < YAW_START_ANGLE)
			{
				motion_data.yaw_data.angle = 8191 - YAW_START_ANGLE + motion_data.yaw_data.angle;
			}
			else
			{
				motion_data.yaw_data.angle = motion_data.yaw_data.angle - YAW_START_ANGLE;
			}
			return true;
			
		case PITCH:
			assign_motor_data(&motion_data.pitch_data,message);
			return true;
			
		default:
			
			
			break;
	}
	return false;
}
/**
* @brief：设定运动模式
* @param [in]	sport_mode:期望的运动模式
* @return：		无
* @author：mqy
*/
void sport_mode_set(sport_mode_e sport_mode)
{
	motion_data.sport_mode = sport_mode;
}
